I. Data types:
###############
    1. alphabet:
        1.1. just a set of letters
        > need to add print
        > need to decide on allowed/prohibited characters
    2. atoms:
        2.1. of two kinds:
            2.1.1. star atoms (a set of letters from an alphabet)
            2.1.2. letter atoms (just a letter from an alphabet)
        > need to add print
        > need to add type-checking
    3. products:
        3.1. a concatenation of atoms (i.e. a list)
        > need to add print
        > need to add type-checking
    4. SREs:
        4.1. a set of products
        > need to add print
        > need to add type-checking
        > might need to add some way of sorting (specifically for entailment
          algorithm)
        > need to add the following
          operations (for all lemmas from [ABJ04]):
          >> compare two SREs for entailment
          >> normalize an SRE
          >> take the left-quotient of an SRE
     5. Actions and action sequences:
        an action is either !w (sending word w) or ?w (reading w)
        we need p⊗ops [lem 6.1] and p⊗ops^* [lem 6.4]
	this involves computing λ(ops), deciding x ≼_c y and x ≼⁺ y among other things
     6. Channel contents: 
         our LCSes have several channels so channel contents are tuples of words, not just single words. 
         Also an action is really some mapping C -> {?,!}×M^* (see p44).
	

II. AN ALTERNATIVE IMPLEMENTATION
The alternative data structure for SREs relies on hash-consing.
This means that when constructing a new sre/product/atom, we check whether
the same sre has already been constructed (and stored in some appropriate
hash-table) in which case we reuse the same object. In principles, the same
operations are performed but some algorithms may be specific, e.g., the
check for equality does not follow [ACBJ04] anymore.

III. LCMS
In order to reproduce the verification of LCMs reported in [ACBJ04], we'll
need a data structure for LCMs. Basically they are directed graphs with
edges carrying actions like !a or ?b. I'd plead for allowing sequences of
actions on edges. It seems that some examples in [ACBJ04] require computing
products of LCMs.
